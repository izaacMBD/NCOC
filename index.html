<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>New Copper, Old Copper ‚Äî 6x6</title>
  <style>
    :root{
      --bg: #0d0d0d;
      --panel: #1a1a1a;
      --grid: #2b2b2b;
      --cell: #141414;
      --text: #e0e0e0;
      --muted: #999;
      --blue: #3498db;
      --red: #e74c3c;
      --ok: #2ecc71;
      --warn: #f39c12;
    }

    *{box-sizing:border-box; margin:0; padding:0;}

    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      display:flex;
      min-height:100vh;
      align-items:center;
      justify-content:center;
      padding:16px;
    }

    .wrap{ 
      display:grid; 
      gap:16px; 
      width:min(1100px, 100%); 
      grid-template-columns: 1fr 320px;
    }
    @media (max-width: 920px){ .wrap{ grid-template-columns: 1fr } }

    .board{
      background: var(--panel);
      border-radius: 12px; 
      padding: 16px;
      border: 1px solid var(--grid);
    }

    .grid{ 
      display:grid; 
      grid-template-columns: repeat(6,1fr); 
      grid-template-rows: repeat(6,1fr); 
      gap: 6px; 
    }

    .cell{
      aspect-ratio: 1/1; 
      border-radius: 8px; 
      background: var(--cell); 
      border: 1px solid var(--grid); 
      display:grid; 
      place-items:center;
      font-size: 26px;
      cursor:pointer;
      user-select:none;
      transition: background .15s;
    }
    .cell:hover{ background:#1f1f1f; }
    .cell.valid{ outline:2px dashed var(--ok); outline-offset:2px; }
    .cell.invalid-hover{ outline:2px dashed var(--red); outline-offset:2px; }
    .cell.disabled{ pointer-events:none; opacity:.5; }

    .piece{ font-weight:700; }
    .blue{ color:var(--blue); }
    .red{ color:var(--red); }

    .side{
      background: var(--panel);
      border-radius:12px; 
      padding:16px;
      border: 1px solid var(--grid);
      display:flex; 
      flex-direction:column; 
      gap:14px;
    }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .btn{
      background: #1f1f1f;
      border: 1px solid #333;
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor:pointer;
      font-weight:500;
      font-size: 14px;
      transition: background .15s, transform .1s;
    }
    .btn:hover{ background:#2b2b2b; transform: translateY(-1px); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn.ghost{ background:transparent; border-color:#444 }
    .btn.primary{ background:#2c3e50; border-color:#3d566e }
    .btn.warn{ background:#3a2a00; border-color:#7a5a00 }

    .chip{ background:#1f1f1f; border:1px solid #333; padding:4px 8px; border-radius:999px; font-size:13px; }
    .legend{ display:grid; grid-template-columns: 1fr 1fr; gap:6px; }
    .legend div{ background:#141414; border:1px solid #2b2b2b; border-radius:8px; padding:6px 8px; font-size:13px; }

    .headline{ font-size:16px; font-weight:700; color:var(--text); }
    .sub{ color:var(--muted); font-size:12px; }
    .turn{ font-weight:700; }

    dialog{ border:none; border-radius:12px; padding:0; overflow:hidden; }
    .modal{
      background: var(--panel); 
      color: var(--text); 
      padding:16px; 
      width:min(420px, 92vw); 
      display:flex; 
      flex-direction:column; 
      gap:12px;
      border: 1px solid var(--grid);
    }

    .budget{ font-weight:700; }
    .adj{ display:grid; grid-template-columns: repeat(4, 1fr); gap:6px }
    .adj button{ aspect-ratio:1/1; border-radius:8px; font-size:20px }
    .muted{ opacity:.7 }

    .footer{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:6px }

    #endGameModal::backdrop{ background:rgba(0,0,0,.7); }
    #endGameModal .modal{ text-align:center; }

    /* Modal do Manual */
#manualDialog::backdrop {
  background: rgba(0, 0, 0, 0.7);
}
#manualDialog {
  border: none;
  border-radius: 12px;
  padding: 0;
  width: min(600px, 90vw);
}
#manualDialog .manual-content {
  background: var(--panel);
  color: var(--text);
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  max-height: 80vh;
  overflow-y: auto;
}
#manualDialog h2 {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: 6px;
}
#manualDialog .close-btn {
  align-self: flex-end;
  margin-top: 10px;
}

  </style>
</head>
<body>
  <!-- Modal Manual -->
<dialog id="manualDialog">
  <div class="manual-content">
    <h2>Manual do Jogo: New Copper, Old Copper ‚Äî 6√ó6</h2>

    <p><strong>üéØ Objetivo</strong><br>
    O objetivo √© somar mais pontos que o advers√°rio colocando pe√ßas no tabuleiro 6√ó6.</p>

    <p><strong>üß© Pe√ßas</strong><br>
    ‚ô§ Lisa (1 ponto) ‚Üí qualquer espa√ßo.<br>
    ‚ô° Serrada (2 pontos) ‚Üí soma ‚â• 2.<br>
    ‚óá Lustrada (3 pontos) ‚Üí soma ‚â• 3.<br>
    ‚ôß Entalhada (4 pontos) ‚Üí soma ‚â• 4.</p>

    <p><strong>üïπÔ∏è Modos de jogo</strong><br>
    PvBot (Bot come√ßa como vermelho)<br>
    PvP (dois jogadores humanos: azul e vermelho).</p>

    <p><strong>üìä Placar</strong><br>
    Mostra a pontua√ß√£o. O jogo acaba quando o tabuleiro enche.</p>

    <p><strong>‚öôÔ∏è Controles</strong><br>
    - Selecionar pe√ßa<br>
    - Colocar pe√ßa<br>
    - Alternar Tema<br>
    - Reiniciar Partida<br>
    - Zerar Placar</p>

    <p><strong>üèÜ Fim do jogo</strong><br>
    O vencedor aparece em uma janela. Pode dar empate.</p>

    <button class="btn primary close-btn" id="closeManual">Fechar e Jogar</button>
  </div>
</dialog>

  <div class="wrap">
    <section class="board">
      <div class="row" style="justify-content:space-between; margin-bottom:10px">
        <div>
          <div class="headline">New Copper, Old Copper ‚Äî 6√ó6</div>
          <div class="sub">Suas pe√ßas <span class="blue">(azuis)</span>; Oponente <span class="red">(vermelhas)</span></div>
        </div>
        <div class="row">
          <span class="chip">Placar: <span id="scoreP">0</span> ‚Äî <span id="scoreB">0</span></span>
          <span class="chip">Turno: <span class="turn" id="turnTxt">Voc√™</span></span>
        </div>
      </div>
      <div id="grid" class="grid" aria-label="Tabuleiro 6x6"></div>
    </section>

    <aside class="side">
      <div class="headline">Pe√ßas</div>
      <div class="legend">
        <div>‚ô§ Lisa ‚Äî valor 1</div>
        <div>‚ô° Serrada ‚Äî valor 2</div>
        <div>‚óá Lustrada ‚Äî valor 3</div>
        <div>‚ôß Entalhada ‚Äî valor 4</div>
      </div>

      <div class="headline" style="margin-top:8px">Selecionar pe√ßa</div>
      <div class="row">
        <button class="btn" data-pick="1">‚ô§ 1</button>
        <button class="btn" data-pick="2">‚ô° 2</button>
        <button class="btn" data-pick="3">‚óá 3</button>
        <button class="btn" data-pick="4">‚ôß 4</button>
      </div>

      <div class="headline" style="margin-top:8px">A√ß√µes</div>
      <div class="row">
        <button id="endSummon" class="btn warn" disabled>Concluir invoca√ß√£o</button>
        <button id="resetBtn" class="btn ghost">Reiniciar</button>
      </div>

      <!-- Seletor de modo -->
      <div class="headline" style="margin-top:8px">Modo de Jogo</div>
      <div class="row">
        <button id="modePvsB" class="btn primary">Voc√™ come√ßa</button>
        <button id="modeBvsP" class="btn">Bot come√ßa</button>
        <button id="modePvsP" class="btn">Player vs Player</button>
      </div>

      <div class="sub">Dica: ‚ô°/‚óá/‚ôß podem ser colocadas se a soma ortogonal das pe√ßas ao redor do espa√ßo vazio for ‚â• ao valor da pe√ßa.</div>
    </aside>
  </div>

  <!-- Modal de invoca√ß√£o -->
  <dialog id="summonDlg">
    <div class="modal">
      <div class="headline">Invocar pe√ßas adjacentes</div>
      <div>Pe√ßa principal: <span id="summonMain"></span> ¬∑ Or√ßamento: <span class="budget" id="budget">0</span></div>
      <div class="sub">Clique em ‚Üë ‚Üì ‚Üê ‚Üí para ocupar lados livres enquanto houver or√ßamento.</div>
      <div id="adjGrid" class="adj"></div>
      <div class="row">
        <button class="btn" data-sel="1">‚ô§ 1</button>
        <button class="btn" data-sel="2">‚ô° 2</button>
        <button class="btn" data-sel="3">‚óá 3</button>
        <button class="btn" data-sel="4">‚ôß 4</button>
      </div>
      <div class="footer">
        <span class="sub muted">Convoca√ß√µes do turno atual</span>
        <div class="row">
          <button id="clearSummon" class="btn ghost">Limpar</button>
          <button id="closeSummon" class="btn primary">Concluir invoca√ß√£o</button>
        </div>
      </div>
    </div>
  </dialog>

  <!-- Modal de fim de jogo -->
  <dialog id="endGameModal">
    <div class="modal">
      <div id="endGameMsg" class="headline"></div>
      <button id="restartBtn" class="btn primary" style="margin-top:12px">Reiniciar</button>
    </div>
  </dialog>

<script>
(function(){
  const SIZE = 6;
  const gridEl = document.getElementById('grid');
  const scoreP = document.getElementById('scoreP');
  const scoreB = document.getElementById('scoreB');
  const turnTxt = document.getElementById('turnTxt');
  const endSummonBtn = document.getElementById('endSummon');
  const resetBtn = document.getElementById('resetBtn');

  const summonDlg = document.getElementById('summonDlg');
  const summonMain = document.getElementById('summonMain');
  const budgetEl = document.getElementById('budget');
  const adjGrid = document.getElementById('adjGrid');
  const selBtns = [...document.querySelectorAll('[data-sel]')];
  const clearSummonBtn = document.getElementById('clearSummon');
  const closeSummonBtn = document.getElementById('closeSummon');

  const pickBtns = [...document.querySelectorAll('[data-pick]')];

  const endGameModal = document.getElementById('endGameModal');
  const endGameMsg = document.getElementById('endGameMsg');
  const restartBtn = document.getElementById('restartBtn');

  const modePvsB = document.getElementById('modePvsB');
  const modeBvsP = document.getElementById('modeBvsP');
  const modePvsP = document.getElementById('modePvsP');

  // Abrir manual ao carregar
const manualDialog = document.getElementById('manualDialog');
const closeManual = document.getElementById('closeManual');

window.addEventListener('DOMContentLoaded', () => {
  try { manualDialog.showModal(); } catch(e){}
});

closeManual.addEventListener('click', () => {
  manualDialog.close();
});

  const PIECES = {
    1:{sym:'\u2664', val:1, name:'Lisa'},
    2:{sym:'\u2661', val:2, name:'Serrada'},
    3:{sym:'\u25C7', val:3, name:'Lustrada'},
    4:{sym:'\u2667', val:4, name:'Entalhada'},
  };

  // Estado
  let board = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>null));
  let turn = 'P'; // P=Jogador1, B=Bot ou Jogador2
  let selected = 1;
  let scores = {P:0, B:0};
  let summon = null; // {r,c, cap, owner, placements:[]}
  let currentSelSummon = 1;
  let gameMode = "PvsB"; // PvsB, BvsP, PvsP

  // Helpers
  const isHumanTurn = () => (gameMode === 'PvsP') || (gameMode !== 'PvsP' && turn === 'P');

  // --- Grid UI ---
  function buildGrid(){
    gridEl.innerHTML = '';
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const cell = document.createElement('button');
        cell.className='cell';
        cell.setAttribute('data-r', r);
        cell.setAttribute('data-c', c);
        cell.setAttribute('aria-label', `c√©lula ${r+1},${c+1}`);
        cell.addEventListener('click', ()=>onCellClick(r,c));
        gridEl.appendChild(cell);
      }
    }
    refreshBoard();
  }

  function refreshBoard(){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const el = gridEl.children[r*SIZE+c];
        el.innerHTML='';
        const p = board[r][c];
        el.classList.remove('valid','invalid-hover','disabled');
        if(p){
          const span = document.createElement('span');
          span.className = 'piece ' + (p.owner==='P'?'blue':'red');
          span.textContent = PIECES[p.val].sym;
          el.appendChild(span);
          el.classList.add('disabled');
        }
      }
    }
    scoreP.textContent = scores.P;
    scoreB.textContent = scores.B;

    if(gameMode === 'PvsP'){
      turnTxt.textContent = (turn==='P') ? 'Jogador 1' : 'Jogador 2';
    }else{
      turnTxt.textContent = (turn==='P') ? 'Voc√™' : 'Bot';
    }

    updateValidHints();
  }

  function neighbors(r,c){
    const res=[];
    if(r>0) res.push({r:r-1,c});
    if(r<SIZE-1) res.push({r:r+1,c});
    if(c>0) res.push({r,c:c-1});
    if(c<SIZE-1) res.push({r,c:c+1});
    return res;
  }
  function get(r,c){ return (r>=0&&r<SIZE&&c>=0&&c<SIZE)?board[r][c]:null }

  // --- Regra: soma ortogonal >= valor ---
  function canPlaceValue(r,c,val){
    if(get(r,c)) return false;
    if(val===1) return true;
    const sum = neighbors(r,c).reduce((acc,pos)=> acc + (get(pos.r,pos.c)?.val || 0), 0);
    return sum >= val;
  }

  // --- Invoca√ß√£o (summon) ---
  function startSummon(r,c, owner, cap){
    if(cap <= 0) { finishTurn(owner); return; }
    const freeAdj = neighbors(r,c).filter(p=> !get(p.r,p.c)).length;
    if(freeAdj === 0){ finishTurn(owner); return; }

    summon = {r,c, cap, owner, placements:[]};

    // habilita bot√£o lateral para quem est√° invocando (em PvP, ambos podem)
    endSummonBtn.disabled = !(owner === 'P' || gameMode === 'PvsP');

    if(owner === 'P' || gameMode === 'PvsP'){
      openSummonModal();
    }else{
      // Bot: aplicar invoca√ß√µes automaticamente (greedy de 1s)
      let rem = cap;
      for(const pos of neighbors(r,c)){
        if(rem <= 0) break;
        if(!get(pos.r,pos.c)){
          board[pos.r][pos.c] = {val:1, owner:'B'};
          scores.B += 1;
          rem -= 1;
        }
      }
      refreshBoard();
      finishTurn('B');
    }
  }

  function openSummonModal(){
    if(!summon) return;
    const mainPiece = get(summon.r, summon.c);
    summonMain.textContent = mainPiece ? (PIECES[mainPiece.val].sym + ' ' + mainPiece.val) : '';
    budgetEl.textContent = summon.cap - sumPlaced();
    adjGrid.innerHTML = '';

    const dirs = [
      {dr:-1,dc:0,label:'‚Üë'},
      {dr:1,dc:0,label:'‚Üì'},
      {dr:0,dc:-1,label:'‚Üê'},
      {dr:0,dc:1,label:'‚Üí'},
    ];

    dirs.forEach(d=>{
      const rr = summon.r + d.dr;
      const cc = summon.c + d.dc;
      if(rr < 0 || rr >= SIZE || cc < 0 || cc >= SIZE) return;
      const b = document.createElement('button');
      b.className = 'btn';
      b.dataset.pos = rr+','+cc;
      if(get(rr,cc)){
        b.textContent = '√ó';
        b.disabled = true;
      }else{
        const existing = summon.placements.find(p=>p.r===rr && p.c===cc);
        if(existing){
          b.textContent = PIECES[existing.val].sym;
          b.disabled = true;
        }else{
          b.textContent = d.label;
          b.addEventListener('click', ()=> placeSummonedAt(rr,cc));
        }
      }
      adjGrid.appendChild(b);
    });

    updateSummonButtons();
    try { summonDlg.showModal(); } catch(e){}
  }

  function sumPlaced(){ return summon ? summon.placements.reduce((s,p)=> s + p.val, 0) : 0; }
  function remaining(){ return summon ? (summon.cap - sumPlaced()) : 0; }

  function updateSummonButtons(){
    if(!summon) return; // <-- evita erro quando n√£o h√° invoca√ß√£o ativa
    const rem = remaining();

    // desabilita sele√ß√µes > or√ßamento e marca sele√ß√£o atual
    selBtns.forEach(btn=> {
      const v = +btn.dataset.sel;
      btn.disabled = v > rem;
      btn.classList.toggle('active', v === currentSelSummon);
    });

    // atualiza bot√µes das posi√ß√µes adjacentes
    [...adjGrid.children].forEach(ch=>{
      if(!ch.dataset.pos) return;
      const [rr,cc] = ch.dataset.pos.split(',').map(Number);
      const existing = summon.placements.find(p=>p.r===rr && p.c===cc);
      if(existing){
        ch.textContent = PIECES[existing.val].sym;
        ch.disabled = true;
      }else{
        ch.disabled = remaining() < currentSelSummon;
      }
    });

    budgetEl.textContent = rem;
  }

  function placeSummonedAt(r,c){
    if(!summon) return;
    const v = currentSelSummon || 1;
    if(get(r,c)) return;
    if(v > remaining()) return;
    if(summon.placements.some(p=> p.r===r && p.c===c)) return;
    summon.placements.push({r,c,val:v});
    updateSummonButtons();
  }

  function clearSummon(){
    if(!summon) return;
    summon.placements = [];
    openSummonModal(); // reconstr√≥i setas e or√ßamento
  }

  function confirmSummon(){
    if(!summon) return;
    const owner = summon.owner; // <-- guarda antes de limpar
    for(const p of summon.placements){
      if(!get(p.r,p.c)){
        board[p.r][p.c] = {val:p.val, owner};
        scores[owner] += p.val;
      }
    }
    // limpar estado
    try { if(summonDlg.open) summonDlg.close(); } catch(e){}
    summon = null;
    endSummonBtn.disabled = true;
    refreshBoard();
    finishTurn(owner);
  }

  // eventos do modal de invoca√ß√£o
  selBtns.forEach(b=> b.addEventListener('click', ()=>{
    currentSelSummon = +b.dataset.sel;
    updateSummonButtons();
  }));
  clearSummonBtn.addEventListener('click', clearSummon);
  closeSummonBtn.addEventListener('click', confirmSummon);

  // bot√£o lateral "Concluir invoca√ß√£o"
  endSummonBtn.addEventListener('click', confirmSummon);

  // --- Intera√ß√£o do tabuleiro ---
  function onCellClick(r,c){
    // Em PvP, ambos jogam; em PvsB, s√≥ P pode clicar
    if(!isHumanTurn()) return;
    if(get(r,c)) return;
    if(!canPlaceValue(r,c, selected)) return flashInvalid(r,c);

    // coloca pe√ßa principal
    board[r][c] = {val:selected, owner:turn};
    scores[turn] += selected;
    refreshBoard();

    // se pe√ßa > 1: iniciar invoca√ß√£o (abre modal para humano; bot invoca autom√°tico)
    if(selected > 1){
      startSummon(r,c, turn, selected);
    }else{
      finishTurn(turn);
    }
  }

  function flashInvalid(r,c){
    const el = gridEl.children[r*SIZE+c];
    el.classList.add('invalid-hover');
    setTimeout(()=> el.classList.remove('invalid-hover'), 300);
  }

  function updateValidHints(){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const el = gridEl.children[r*SIZE+c];
        el.classList.remove('valid');
        if(!get(r,c) && isHumanTurn() && canPlaceValue(r,c, selected)) el.classList.add('valid');
      }
    }
  }

  // sele√ß√£o de pe√ßa
  pickBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{ selected = +btn.dataset.pick; updateValidHints(); });
  });

  // reset e restart
  resetBtn.addEventListener('click', resetGame);
  restartBtn.addEventListener('click', ()=>{ endGameModal.close(); resetGame(); });

  function resetGame(){
    board = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>null));
    scores = {P:0, B:0};
    turn='P'; selected=1; summon=null; currentSelSummon=1;
    endSummonBtn.disabled = true;
    refreshBoard();
  }

  // --- Turnos e fim de jogo ---
  function finishTurn(owner){
    // troca de turno
    summon = null;
    endSummonBtn.disabled = true;

    if(isBoardFull()) return endGame();

    if(owner === 'P'){
      // passa para B
      turn = 'B';
      refreshBoard();
      // se houver bot (PvsB ou BvsP), deixa o bot jogar
      if(gameMode !== 'PvsP'){
        setTimeout(botTurn, 250);
      }
    }else{
      // passa para P
      turn = 'P';
      refreshBoard();
    }
  }

  function isBoardFull(){
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!board[r][c]) return false;
    return true;
  }

  function endGame(){
    let msg = `Fim de jogo! Placar ‚Äî Voc√™: ${scores.P} ¬∑ ${gameMode==='PvsP'?'Jogador 2':'Bot'}: ${scores.B}.`;
    if(scores.P>scores.B) msg += gameMode==='PvsP' ? ' Jogador 1 venceu!' : ' Voc√™ venceu!';
    else if(scores.P<scores.B) msg += gameMode==='PvsP' ? ' Jogador 2 venceu!' : ' Bot venceu!';
    else msg += ' Empate!';
    endGameMsg.textContent = msg;
    try { endGameModal.showModal(); } catch(e){}
  }

  // --- Bot (heur√≠stica simples + invoca√ß√£o greedy) ---
  function botTurn(){
    if(gameMode === 'PvsP') return; // sem bot
    // gera todos os lances v√°lidos com ganho estimado
    const moves = [];
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(get(r,c)) continue;
        for(const v of [4,3,2,1]){
          if(canPlaceValue(r,c,v)){
            const empties = neighbors(r,c).filter(p=> !get(p.r,p.c)).length;
            const summonOnes = Math.min(v, empties);
            const scoreGain = v + summonOnes;
            moves.push({r,c,val:v,scoreGain});
          }
        }
      }
    }
    if(moves.length === 0){ return finishTurn('B'); }

    moves.sort((a,b)=> b.scoreGain - a.scoreGain || Math.random() - 0.5);
    const m = moves[0];

    board[m.r][m.c] = {val:m.val, owner:'B'};
    scores.B += m.val;

    if(m.val >= 2){
      let rem = m.val;
      for(const pos of neighbors(m.r,m.c)){
        if(rem <= 0) break;
        if(!get(pos.r,pos.c)){
          board[pos.r][pos.c] = {val:1, owner:'B'};
          scores.B += 1;
          rem -= 1;
        }
      }
    }

    refreshBoard();
    finishTurn('B');
  }

  // modos
  modePvsB.addEventListener('click', ()=>{
    resetGame(); gameMode="PvsB"; turn='P'; refreshBoard();
    modePvsB.classList.add('primary');
    modeBvsP.classList.remove('primary');
    modePvsP.classList.remove('primary');
  });
  modeBvsP.addEventListener('click', ()=>{
    resetGame(); gameMode="BvsP"; turn='B'; refreshBoard(); setTimeout(botTurn, 200);
    modeBvsP.classList.add('primary');
    modePvsB.classList.remove('primary');
    modePvsP.classList.remove('primary');
  });
  modePvsP.addEventListener('click', ()=>{
    resetGame(); gameMode="PvsP"; turn='P'; refreshBoard();
    modePvsP.classList.add('primary');
    modePvsB.classList.remove('primary');
    modeBvsP.classList.remove('primary');
  });

  // Inicializar
  buildGrid();
})();
</script>
</body>
</html>
