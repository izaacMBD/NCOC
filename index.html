<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>New Copper, Old Copper — 6x6</title>
  <style>
    :root{
      --blue:#1e90ff;
      --red:#e53935;
      --bg:#0f1220;
      --panel:#171a2b;
      --accent:#8a98ff;
      --grid:#2a2f4a;
      --cell:#1b2040;
      --ok:#13c27a;
      --warn:#ffb703;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial,sans-serif; background:var(--bg); color:#e6e8ff;
      display:flex; min-height:100dvh; align-items:center; justify-content:center; padding:16px;
    }
    .wrap{display:grid; gap:16px; width:min(1100px, 100%); grid-template-columns: 1fr 320px}
    @media (max-width: 920px){ .wrap{grid-template-columns: 1fr} }

    .board{
      background:linear-gradient(180deg, var(--panel), transparent 200px);
      border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .grid{ display:grid; grid-template-columns:repeat(6,1fr); grid-template-rows:repeat(6,1fr); gap:8px; }
    .cell{
      width:100%; aspect-ratio:1/1; border-radius:12px; background:var(--cell); display:grid; place-items:center;
      border:1px solid var(--grid); font-size:28px; position:relative; cursor:pointer; user-select:none;
      transition: transform .08s ease;
    }
    .cell:hover{ transform: translateY(-1px); }
    .cell.valid{ outline:2px dashed var(--ok); outline-offset:2px; }
    .cell.invalid-hover{ outline:2px dashed #ff5252; outline-offset:2px; }
    .cell.disabled{ pointer-events:none; opacity:.5; }

    .piece{ font-weight:700; filter: drop-shadow(0 2px 0 rgba(0,0,0,.35)); }
    .blue{ color:var(--blue); }
    .red{ color:var(--red); }

    .side{
      background:var(--panel); border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
      display:flex; flex-direction:column; gap:14px;
    }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }

    .btn{
      background:#22284f; border:1px solid #4050a0; color:#e6e8ff; padding:10px 12px; border-radius:12px; cursor:pointer;
      font-weight:600; letter-spacing:.2px; transition:.15s ease; display:inline-flex; align-items:center; gap:8px;
    }
    .btn:hover{ transform: translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.25); }
    .btn:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; transform:none; }
    .btn.ghost{ background:transparent; border-color:#394074 }
    .btn.primary{ background:linear-gradient(180deg,#3b46a9,#2d398f); border-color:#4e5bed }
    .btn.warn{ background:#3a2a00; border-color:#7a5a00 }

    .chip{ background:#232955; border:1px solid #394074; padding:6px 10px; border-radius:999px; font-weight:700; }
    .legend{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .legend div{ background:#12162f; border:1px solid #2b3466; border-radius:10px; padding:8px 10px; font-size:14px; }

    .headline{ font-size:18px; font-weight:800; color:#cbd2ff; letter-spacing:.3px }
    .sub{ color:#aeb6ff; font-size:13px }
    .turn{ font-weight:800; }

    dialog{ border:none; border-radius:16px; padding:0; overflow:hidden; box-shadow:0 20px 60px rgba(0,0,0,.5) }
    .modal{
      background:var(--panel); color:#e6e8ff; padding:16px; width:min(420px, 92vw); display:flex; flex-direction:column; gap:12px;
    }
    .budget{ font-weight:800; }
    .adj{ display:grid; grid-template-columns: repeat(4, 1fr); gap:8px }
    .adj button{ aspect-ratio:1/1; border-radius:12px; font-size:22px }
    .muted{ opacity:.7 }

    .footer{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:6px }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="board">
      <div class="row" style="justify-content:space-between; margin-bottom:10px">
        <div>
          <div class="headline">New Copper, Old Copper — 6×6</div>
          <div class="sub">Suas peças <span class="blue">(azuis)</span>; Bot <span class="red">(vermelhas)</span></div>
        </div>
        <div class="row">
          <span class="chip">Placar: <span id="scoreP">0</span> — <span id="scoreB">0</span></span>
          <span class="chip">Turno: <span class="turn" id="turnTxt">Você</span></span>
        </div>
      </div>
      <div id="grid" class="grid" aria-label="Tabuleiro 6x6"></div>
    </section>

    <aside class="side">
      <div class="headline">Peças</div>
      <div class="legend">
        <div>♤ Lisa — valor 1</div>
        <div>♡ Serrada — valor 2</div>
        <div>◇ Lustrada — valor 3</div>
        <div>♧ Entalhada — valor 4</div>
      </div>

      <div class="headline" style="margin-top:8px">Selecionar peça</div>
      <div class="row">
        <button class="btn" data-pick="1">♤ 1</button>
        <button class="btn" data-pick="2">♡ 2</button>
        <button class="btn" data-pick="3">◇ 3</button>
        <button class="btn" data-pick="4">♧ 4</button>
      </div>

      <div class="headline" style="margin-top:8px">Ações</div>
      <div class="row">
        <button id="endSummon" class="btn warn" disabled>Concluir invocação</button>
        <button id="resetBtn" class="btn ghost">Reiniciar</button>
      </div>

      <div class="sub">Dica: coloque peças conforme as restrições. ♡/◇/♧ podem invocar peças nos lados livres no mesmo turno com soma ≤ ao seu valor.</div>
    </aside>
  </div>

  <!-- Modal de invocação -->
  <dialog id="summonDlg">
    <div class="modal">
      <div class="headline">Invocar peças adjacentes</div>
      <div>Peça principal: <span id="summonMain"></span> · Orçamento: <span class="budget" id="budget">0</span></div>
      <div class="sub">Clique nos lados livres para colocar peças até gastar o orçamento. As peças invocadas ignoram as regras normais, mas devem caber no orçamento e ser ortogonais à peça principal.</div>
      <div id="adjGrid" class="adj"></div>
      <div class="row">
        <button class="btn" data-sel="1">♤ 1</button>
        <button class="btn" data-sel="2">♡ 2</button>
        <button class="btn" data-sel="3">◇ 3</button>
        <button class="btn" data-sel="4">♧ 4</button>
      </div>
      <div class="footer">
        <span class="sub muted">Convocações do seu turno</span>
        <div class="row">
          <button id="clearSummon" class="btn ghost">Limpar</button>
          <button id="closeSummon" class="btn primary">Concluir invocação</button>
        </div>
      </div>
    </div>
  </dialog>

<script>
(function(){
  const SIZE = 6;
  const gridEl = document.getElementById('grid');
  const scoreP = document.getElementById('scoreP');
  const scoreB = document.getElementById('scoreB');
  const turnTxt = document.getElementById('turnTxt');
  const endSummonBtn = document.getElementById('endSummon');
  const resetBtn = document.getElementById('resetBtn');

  const summonDlg = document.getElementById('summonDlg');
  const summonMain = document.getElementById('summonMain');
  const budgetEl = document.getElementById('budget');
  const adjGrid = document.getElementById('adjGrid');
  const selBtns = [...document.querySelectorAll('[data-sel]')];
  const clearSummonBtn = document.getElementById('clearSummon');
  const closeSummonBtn = document.getElementById('closeSummon');

  const pickBtns = [...document.querySelectorAll('[data-pick]')];

  const PIECES = {
    1:{sym:'\u2664', val:1, name:'Lisa'},
    2:{sym:'\u2661', val:2, name:'Serrada'},
    3:{sym:'\u25C7', val:3, name:'Lustrada'},
    4:{sym:'\u2667', val:4, name:'Entalhada'},
  };

  // Estado do jogo
  let board = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>null));
  let turn = 'P'; // P=Player (azul), B=Bot (vermelho)
  let selected = 1; // peça escolhida pelo jogador
  let scores = {P:0, B:0};

  // Estado de invocação (somente no turno corrente)
  let summon = null; // {r,c, cap, owner:'P'|'B', placements:[{r,c,val}]}

  // UI inicial
  function buildGrid(){
    gridEl.innerHTML = '';
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const idx = r*SIZE+c;
        const cell = document.createElement('button');
        cell.className='cell';
        cell.setAttribute('data-r', r);
        cell.setAttribute('data-c', c);
        cell.setAttribute('aria-label', `célula ${r+1},${c+1}`);
        cell.addEventListener('mouseenter', ()=>highlightCell(r,c));
        cell.addEventListener('mouseleave', ()=>clearHighlights());
        cell.addEventListener('click', ()=>onCellClick(r,c));
        gridEl.appendChild(cell);
      }
    }
    refreshBoard();
  }

  function refreshBoard(){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const el = gridEl.children[r*SIZE+c];
        el.innerHTML='';
        const p = board[r][c];
        if(p){
          const span = document.createElement('span');
          span.className = 'piece ' + (p.owner==='P'?'blue':'red');
          span.textContent = PIECES[p.val].sym;
          el.appendChild(span);
          el.classList.add('disabled');
        }else{
          el.classList.remove('disabled');
        }
      }
    }
    scoreP.textContent = scores.P;
    scoreB.textContent = scores.B;
    turnTxt.textContent = turn==='P'?'Você':'Bot';
    updateValidHints();
  }

  function neighbors(r,c){
    const res=[];
    if(r>0) res.push({r:r-1,c});
    if(r<SIZE-1) res.push({r:r+1,c});
    if(c>0) res.push({r,c:c-1});
    if(c<SIZE-1) res.push({r,c:c+1});
    return res;
  }
  function get(r,c){ return (r>=0&&r<SIZE&&c>=0&&c<SIZE)?board[r][c]:null }

  // ===== Regras de posicionamento =====
  function canPlaceAnywhere(r,c){ return !get(r,c) }

  function isBetweenOpposite(r,c, condLR, condUD){
    // condLR(a,b) true se valores dos lados esq/dir satisfazem; condUD para cima/baixo
    const L = get(r,c-1)?.val, R = get(r,c+1)?.val, U = get(r-1,c)?.val, D = get(r+1,c)?.val;
    return (L!=null && R!=null && condLR(L,R)) || (U!=null && D!=null && condUD(U,D));
  }

  function countAdjVals(r,c, val){
    return neighbors(r,c).reduce((n,pos)=> n + (get(pos.r,pos.c)?.val===val?1:0), 0);
  }

  function adjValsMultiset(r,c){
    return neighbors(r,c).map(p=>get(p.r,p.c)?.val).filter(v=>v!=null);
  }

  function canPlaceValue(r,c,val){
    if(get(r,c)) return false;
    if(val===1) return true; // ♤ em qualquer lugar

    const hasNeighborGE = (thr)=>neighbors(r,c).some(p=> (get(p.r,p.c)?.val||0) >= thr);

    if(val===2){
      const betweenTwo1 = isBetweenOpposite(r,c, (a,b)=>a===1&&b===1, (a,b)=>a===1&&b===1);
      const nextTo234 = neighbors(r,c).some(p=>{const v=get(p.r,p.c)?.val; return v===2||v===3||v===4});
      return betweenTwo1 || nextTo234;
    }
    if(val===3){
      const three1 = countAdjVals(r,c,1) >= 3;
      const between1and2 = isBetweenOpposite(r,c, (a,b)=> (a===1&&b===2)||(a===2&&b===1), (a,b)=> (a===1&&b===2)||(a===2&&b===1));
      const between22 = isBetweenOpposite(r,c, (a,b)=> a===2&&b===2, (a,b)=> a===2&&b===2);
      const nextTo34 = neighbors(r,c).some(p=>{const v=get(p.r,p.c)?.val; return v===3||v===4});
      return three1 || between1and2 || between22 || nextTo34;
    }
    if(val===4){
      const four1 = countAdjVals(r,c,1) === 4;
      const between22 = isBetweenOpposite(r,c, (a,b)=> a===2&&b===2, (a,b)=> a===2&&b===2);
      const has112 = (()=>{
        const vals = adjValsMultiset(r,c);
        let ones=0, twos=0;
        vals.forEach(v=>{ if(v===1) ones++; else if(v===2) twos++; });
        return ones>=2 && twos>=1;
      })();
      const between13 = isBetweenOpposite(r,c, (a,b)=> (a===1&&b===3)||(a===3&&b===1), (a,b)=> (a===1&&b===3)||(a===3&&b===1));
      const between33 = isBetweenOpposite(r,c, (a,b)=> a===3&&b===3, (a,b)=> a===3&&b===3);
      const nextTo4 = neighbors(r,c).some(p=> (get(p.r,p.c)?.val)===4);
      return four1 || between22 || has112 || between13 || between33 || nextTo4;
    }
    return false;
  }

  // ===== Invocação =====
  function startSummon(r,c, owner, cap){
    if(cap<=0) return finishTurn(owner);
    summon = {r,c, cap, owner, placements:[]};
    endSummonBtn.disabled = owner!=='P';
    if(owner==='P') openSummonModal();
  }

  function openSummonModal(){
    // construir UI de 4 lados
    summonMain.textContent = PIECES[get(summon.r,summon.c).val].sym + ' ' + get(summon.r,summon.c).val;
    budgetEl.textContent = summon.cap - sumPlaced();
    adjGrid.innerHTML='';
    const dirs = [
      {dr:-1,dc:0,label:'↑'},
      {dr:1,dc:0,label:'↓'},
      {dr:0,dc:-1,label:'←'},
      {dr:0,dc:1,label:'→'},
    ];
    dirs.forEach(d=>{
      const rr = summon.r + d.dr, cc = summon.c + d.dc;
      const b = document.createElement('button');
      b.className='btn';
      b.dataset.pos = rr+','+cc;
      b.textContent = get(rr,cc)?'×':d.label;
      b.disabled = !!get(rr,cc);
      b.addEventListener('click', ()=> placeSummonedAt(rr,cc));
      adjGrid.appendChild(b);
    });
    updateSummonButtons();
    summonDlg.showModal();
  }

  function sumPlaced(){ return summon.placements.reduce((s,p)=>s+p.val,0); }
  function remaining(){ return summon.cap - sumPlaced(); }

  function updateSummonButtons(){
    const rem = remaining();
    selBtns.forEach(btn=>{ const v = +btn.dataset.sel; btn.disabled = v>rem; });
    budgetEl.textContent = rem;
  }

  function placeSummonedAt(r,c){
    const v = currentSelSummon;
    if(!v) return;
    if(get(r,c)) return;
    if(v>remaining()) return;
    // registrar, mas só aplicar ao tabuleiro ao concluir
    summon.placements.push({r,c,val:v});
    // desabilitar botão correspondente
    [...adjGrid.children].forEach(ch=>{
      const [rr,cc] = ch.dataset.pos.split(',').map(Number);
      if(rr===r && cc===c){ ch.textContent = PIECES[v].sym; ch.disabled = true; }
    });
    updateSummonButtons();
  }

  function clearSummon(){
    summon.placements = [];
    openSummonModal(); // rebuild
  }

  function closeSummon(){
    summonDlg.close();
    applySummonPlacements();
    finishTurn(summon.owner);
  }

  function applySummonPlacements(){
    for(const p of summon.placements){
      board[p.r][p.c] = {val:p.val, owner:summon.owner};
      scores[summon.owner]+=p.val;
    }
  }

  let currentSelSummon = 1;
  selBtns.forEach(b=> b.addEventListener('click', ()=>{ currentSelSummon = +b.dataset.sel; updateSummonButtons(); }));
  clearSummonBtn.addEventListener('click', clearSummon);
  closeSummonBtn.addEventListener('click', closeSummon);

  endSummonBtn.addEventListener('click', ()=>{
    // atalho para concluir (sem modal aberto)
    if(summon && summon.owner==='P'){
      applySummonPlacements();
      finishTurn('P');
    }
  });

  // ===== Interação do tabuleiro =====
  function onCellClick(r,c){
    if(get(r,c)) return;
    if(turn==='P'){
      if(!canPlaceValue(r,c, selected)) return flashInvalid(r,c);
      placePiece(r,c, selected, 'P');
      const cap = selected; // orçamento de invocação igual ao valor da peça
      if(cap>0 && (selected===2||selected===3||selected===4)) startSummon(r,c,'P',cap);
      else finishTurn('P');
    }
  }

  function placePiece(r,c,val, owner){
    board[r][c] = {val, owner};
    scores[owner]+=val;
    refreshBoard();
  }

  function flashInvalid(r,c){
    const el = gridEl.children[r*SIZE+c];
    el.classList.add('invalid-hover');
    setTimeout(()=> el.classList.remove('invalid-hover'), 300);
  }

  function updateValidHints(){
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const el = gridEl.children[r*SIZE+c];
        el.classList.remove('valid');
        if(!get(r,c) && turn==='P' && canPlaceValue(r,c, selected)) el.classList.add('valid');
      }
    }
  }

  function highlightCell(r,c){
    // já usamos updateValidHints
  }
  function clearHighlights(){ /* noop */ }

  pickBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{ selected = +btn.dataset.pick; updateValidHints(); });
  });

  resetBtn.addEventListener('click', ()=>{ resetGame(); });

  function resetGame(){
    board = Array.from({length:SIZE}, ()=>Array.from({length:SIZE}, ()=>null));
    scores = {P:0, B:0};
    turn='P';
    selected=1; summon=null; currentSelSummon=1;
    refreshBoard();
  }

  // ===== Turnos e fim de jogo =====
  function finishTurn(owner){
    summon=null; endSummonBtn.disabled = true;
    refreshBoard();

    if(isBoardFull()) return endGame();

    if(owner==='P'){
      // turno do bot
      turn='B'; refreshBoard();
      setTimeout(botTurn, 300);
    }else{
      // volta ao jogador
      turn='P'; refreshBoard();
    }
  }

  function isBoardFull(){
    for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(!board[r][c]) return false; return true;
  }

  function endGame(){
    let msg = `Fim de jogo! Placar — Você: ${scores.P} · Bot: ${scores.B}.\n`;
    if(scores.P>scores.B) msg += 'Você venceu!';
    else if(scores.P<scores.B) msg += 'Bot venceu!';
    else msg += 'Empate!';
    alert(msg);
  }

  // ===== Bot =====
  function botTurn(){
    // Estratégia simples: procurar jogada legal com maior pontuação no turno (peça + invocações de 1s)
    const moves=[];
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        if(get(r,c)) continue;
        for(const v of [4,3,2,1]){
          if(canPlaceValue(r,c,v)){
            // simular quantos adjacentes livres existem para invocar
            const empties = neighbors(r,c).filter(p=>!get(p.r,p.c)).length;
            const cap = v;
            const summonValue = (v>=2) ? Math.min(cap, empties*1) : 0; // invocar 1s
            const scoreGain = v + summonValue;
            moves.push({r,c,val:v, scoreGain});
          }
        }
      }
    }
    if(moves.length===0){ return finishTurn('B'); }
    // escolher melhor; desempate aleatório leve
    moves.sort((a,b)=> b.scoreGain - a.scoreGain || Math.random()-0.5);
    const m = moves[0];
    placePiece(m.r,m.c,m.val,'B');
    if(m.val>=2){
      // realizar invocação gananciosa de 1s
      let rem = m.val;
      for(const pos of neighbors(m.r,m.c)){
        if(rem<=0) break;
        if(!get(pos.r,pos.c)){
          board[pos.r][pos.c] = {val:1, owner:'B'};
          scores.B += 1; rem -= 1;
        }
      }
      refreshBoard();
    }
    finishTurn('B');
  }

  // Inicializar
  buildGrid();
})();
</script>
</body>
</html>
